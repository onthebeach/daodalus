<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Daodalus by onthebeach</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Daodalus</h1>
        <p class="header">DSL for building MongoDB queries, updates and aggregations</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/onthebeach/daodalus/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/onthebeach/daodalus/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/onthebeach/daodalus">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/onthebeach">onthebeach</a></p>


      </header>
      <section>
        <h1>
<a name="daodalus---" class="anchor" href="#daodalus---"><span class="octicon octicon-link"></span></a>DAODALUS  <a href="http://travis-ci.org/onthebeach/daodalus"><img src="https://travis-ci.org/onthebeach/daodalus.png" alt="Build Status"></a> <a href="https://codeclimate.com/github/onthebeach/daodalus"><img src="https://codeclimate.com/github/onthebeach/daodalus.png" alt="Code Climate"></a>
</h1>

<h3>
<a name="take-the-sting-out-of-constructing-complex-mongodb-queries-updates-and-aggregations" class="anchor" href="#take-the-sting-out-of-constructing-complex-mongodb-queries-updates-and-aggregations"><span class="octicon octicon-link"></span></a>Take the sting out of constructing complex MongoDB queries, updates and aggregations.</h3>

<p>In Greek mythology, Daedalus tried to prevent Icarus from flying too close to the sun, but Icarus ignored his father's warning, the wax holding together his wings melted, and he fell to his death. 'Daodalus' hopes to succeed where Daedalus failed by preventing your application code from flying too close to the code that interacts with your datastore.</p>

<p>Originally conceived of as an implementation of the Data Access Object pattern, it has evolved since then into more of a DSL to simplify doing complicated things with Mongo. However, by separating your models from the object used to interact with their stored form, we hope Daodalus still encourages your application and data layers to keep their distance from each other.</p>

<h2>
<a name="registering-connections" class="anchor" href="#registering-connections"><span class="octicon octicon-link"></span></a>Registering connections</h2>

<p>Before being able to use Daodalus you will need to create and register one or more connections to your instance (or instances) of MongoDB. Here's how you do it:</p>

<pre><code>conn = Mongo::MongoClient.new('localhost', 27017, pool_size: 5)
Daodalus::Connection.register(conn, :name)
</code></pre>

<p>If you leave off the name, the connection will be registered as <code>:default</code>.</p>

<p>The connection can be any MongoDB connection class provided by the Ruby Mongo Driver - so you could also use a <code>MongoShardedClient</code> or <code>MongoReplicaSetClient</code> here.</p>

<h2>
<a name="creating-a-dao" class="anchor" href="#creating-a-dao"><span class="octicon octicon-link"></span></a>Creating a DAO</h2>

<p>Create a DAO by specifying a database and collection (and optional connection name, defaulting to 'default'):</p>

<pre><code>dao = Daodalus::DAO.new(:my_db, :my_collection, :my_connection)
</code></pre>

<p>The <code>connection</code> name must match one of the connections you registered earlier.</p>

<h2>
<a name="access-to-mongodb-collection-methods" class="anchor" href="#access-to-mongodb-collection-methods"><span class="octicon octicon-link"></span></a>Access to MongoDB Collection Methods</h2>

<p>You now have access to several basic MongoDB methods as defined on the <code>Mongo::Collection</code> class of the MongoDB Ruby driver. The following methods work unchanged:</p>

<ul>
<li><code>#find</code></li>
<li><code>#update</code></li>
<li><code>#insert</code></li>
<li><code>#save</code></li>
<li><code>#remove</code></li>
<li><code>#count</code></li>
<li><code>#aggregate</code></li>
</ul><p>However, <code>#find_one</code> and <code>#find_and_modify</code> work slightly differently. While the original methods return either the matched document or <code>nil</code>, Daodalus is allergic to <code>nil</code>s, and so avoids them by using optional types instead. So the values returned will be either <code>Some[value]</code> or <code>None</code>. You can read more about optional types and see the implementation used by Daodalus <a href="http://github.com/rsslldnphy/optional">here</a>.</p>

<p>These are the only methods exposed by the Daodalus DAO - but should you need to call any other methods on the collection, the <code>Mongo::Collection</code> object can be accessed directly by calling <code>dao.coll</code>.</p>

<h2>
<a name="queries" class="anchor" href="#queries"><span class="octicon octicon-link"></span></a>Queries</h2>

<p>Queries are built up by chaining together one or more 'where' clauses, like this:</p>

<pre><code>dao.where(:name).eq('Terry').and(:paws).gte(3).find
</code></pre>

<p>Note that a longer-form version of the clause name usually exists as an alias if you prefer to be a bit more verbose. So the above could equally be expressed as:</p>

<pre><code>dao.where(:name).equals('Terry').and(:paws).greater_than_or_equal(3).find
</code></pre>

<p>Notice the <code>find</code> at the end of the chain? This is what terminates the chain and sends your query to Mongo. You can also use <code>find_one</code> here (which, remember, will return an <code>Option</code>) as well as some other methods for updating and aggregation that we'll come to later.</p>

<p>If you need to make multiple assertions about the same field, you can simply chain them like this:</p>

<pre><code>dao.where(:paws).gt(2).lt(5).find
</code></pre>

<p>But bear in mind that it's not possible to make an equality assertion <em>and</em> another assertion on the same field. (Which makes sense if you think about it.) This will raise an <code>InvalidQueryError</code>.</p>

<p>Querying against nested fields works just like it does in plain Mongo, using the dot operator. (You can pass field names as strings or symbols, it's up to you.)</p>

<pre><code>dao.where(:'paws.2.toes').gt(3) # the third element of the paws array has a toes field that is &gt; than 3
</code></pre>

<p>Here is the complete list of currently implemented 'where' clauses you can use with Daodalus.</p>

<table>
<tr>
<th>Clause</th>
<th>Alias</th>
<th>Usage</th>
<th>Translation</th>
</tr>
<tr>
<td><code>#eq</code></td>
<td><code>#equals</code></td>
<td><code>dao.where(:paws).eq(4)</code></td>
<td><code>{ 'paws' : 4 }</code></td>
</tr>
<tr>
<td><code>#ne</code></td>
<td><code>#not_equal</code></td>
<td><code>dao.where(:paws).ne(4)</code></td>
<td><code>{ 'paws' : { '$ne' : 4 } }</code></td>
</tr>
<tr>
<td><code>#lt</code></td>
<td><code>#less_than</code></td>
<td><code>dao.where(:paws).lt(4)</code></td>
<td><code>{ 'paws' : { '$lt' : 4 } }</code></td>
</tr>
<tr>
<td><code>#gt</code></td>
<td><code>#greater_than</code></td>
<td><code>dao.where(:paws).gt(4)</code></td>
<td><code>{ 'paws' : { '$gt' : 4 } }</code></td>
</tr>
<tr>
<td><code>#lte</code></td>
<td><code>#less_than_or_equal</code></td>
<td><code>dao.where(:paws).lte(4)</code></td>
<td><code>{ 'paws' : { '$lte' : 4 } }</code></td>
</tr>
<tr>
<td><code>#gte</code></td>
<td><code>#greater_than_or_equal</code></td>
<td><code>dao.where(:paws).gte(4)</code></td>
<td><code>{ 'paws' : { '$gte' : 4 } }</code></td>
</tr>
<tr>
<td><code>#in</code></td>
<td>-</td>
<td><code>dao.where(:paws).in(4, 3)</code></td>
<td><code>{ 'paws' : { '$in' : [4, 3] } }</code></td>
</tr>
<tr>
<td><code>#nin</code></td>
<td><code>#not_in</code></td>
<td><code>dao.where(:paws).gte(4)</code></td>
<td><code>{ 'paws' : { '$nin' : [4, 3] } }</code></td>
</tr>
<tr>
<td><code>#all</code></td>
<td>-</td>
<td><code>dao.where(:likes).all('tuna', 'catnip')</code></td>
<td><code>{ 'likes' : { '$all' : ['tuna', 'catnip'] } }</code></td>
</tr>
<tr>
<td><code>#size</code></td>
<td>-</td>
<td><code>dao.where(:likes).size(3)</code></td>
<td><code>{ 'likes' : { '$size' : 3 } }</code></td>
</tr>
<tr>
<td><code>#exists</code></td>
<td>-</td>
<td><code>dao.where(:tail).exists</code></td>
<td><code>{ 'tail' : { '$exists' : true } }</code></td>
</tr>
<tr>
<td><code>#does_not_exist</code></td>
<td><code>#exists(false)</code></td>
<td><code>dao.where(:tail).does_not_exist</code></td>
<td><code>{ 'tail' : { '$exists' : false } }</code></td>
</tr>
</table><h3>
<a name="logic" class="anchor" href="#logic"><span class="octicon octicon-link"></span></a>Logic</h3>

<p>Using <code>#not</code> will negate the following where clause (one only), whatever it might be. So:</p>

<pre><code>dao.where(:paws).not.gte(4)
</code></pre>

<p>translates as:</p>

<pre><code>{ 'paws' : { '$not' : { '$gte' : 4 } } }
</code></pre>

<p>The MongoDB <code>or</code> and <code>nor</code> operators have different names in Daodalus so that they make more sense in the context they're in. So, to match <em>any</em> of a set of clauses, use <code>#any</code> like this:</p>

<pre><code>dao.where.any(
  dao.where(:paws).eq(3),
  dao.where(:name).eq('Terry')
)

# translates as { '$or' : [ { 'paws' : 3 }, { 'name' : 'Terry' }] }
</code></pre>

<p>...and to match only if <em>none</em> of a set of clauses match, use <code>#none</code>:</p>

<pre><code>dao.where.none(
  dao.where(:paws).eq(3),
  dao.where(:name).eq('Terry')
)

# translates as { '$nor' : [ { 'paws' : 3 }, { 'name' : 'Terry' }] }
</code></pre>

<h3>
<a name="matching-array-elements" class="anchor" href="#matching-array-elements"><span class="octicon octicon-link"></span></a>Matching array elements</h3>

<p>You can also ensure a specific array element matches a number of conditions using the <code>#elem_match</code> method.</p>

<pre><code>dao.where(:foods).elem_match(
  dao.where(:type).eq(:wet).and(:name).eq("Whiskas")
)

# translates as { 'foods' : { '$elemMatch' : { 'type' : 'wet', 'name' : 'Whiskas' } } }
</code></pre>

<p>This will match only documents with a <code>foods</code> array which contains an element with a <code>type</code> value of "wet" <em>and</em> a <code>name</code> value of "Whiskas".</p>

<h2>
<a name="selecting-fields-to-be-returned-projection" class="anchor" href="#selecting-fields-to-be-returned-projection"><span class="octicon octicon-link"></span></a>Selecting Fields to be Returned (Projection)</h2>

<p>You don't always want the whole document to be returned. Mongo allows you to specify which fields you're interested in. To do this in Daodalus, use <code>#select</code>. Here's how to specify a bunch of fields to be selected:</p>

<pre><code>dao.select(:name, :paws, :tail)
</code></pre>

<p>NB. Although MongoDB <em>always</em> selects the <code>_id</code> field by default, Daodalus does not do this (in order to reduce the number of 'special cases'). If you need the <code>_id</code> field, simply specify it as part of the select.</p>

<h3>
<a name="chaining-selects" class="anchor" href="#chaining-selects"><span class="octicon octicon-link"></span></a>Chaining selects</h3>

<p>If you're selecting lots of fields, you may wish to split the statement over multiple lines - or you could wish to separate groups of selected fields for semantic reasons. To help keep this neat, selects can be chained with the <code>and</code> method like this:</p>

<pre><code>dao.select(:cats, :dogs, :fish).and(:pigs, :sheep, :horseys)
</code></pre>

<h3>
<a name="the-positional-operator" class="anchor" href="#the-positional-operator"><span class="octicon octicon-link"></span></a>The positional operator</h3>

<p>In Mongo, if you want to select only the first matched subdocument in an array you use the positional operator (<code>$</code>). In Daodalus, we've given that the slightly more descriptive name of <code>#by_position</code>. Use it like this:</p>

<pre><code>dao.select(:cats).by_position.where(:'cats.paws').gt(3) # select and return only the first cat with &gt; 3 paws
</code></pre>

<h3>
<a name="slice" class="anchor" href="#slice"><span class="octicon octicon-link"></span></a>Slice</h3>

<p>To select a subsection of an array, use <code>#slice</code>.</p>

<pre><code>dao.select(:favourite_foods).slice(4)      # get the first four
dao.select(:favourite_foods).slice(-4)     # get the last four
dao.select(:favourite_foods).slice(10, 4)  # get four, starting with the 10th
dao.select(:favourite_foods).slice(-10, 4) # get four, starting with the 10th from last
</code></pre>

<h3>
<a name="elem_match" class="anchor" href="#elem_match"><span class="octicon octicon-link"></span></a>Elem_match</h3>

<p>It's also possible to use <code>#elem_match</code> as part of a select clause, in a similar way to how it's used in a where clause. This time, it makes sure that only the first element in an array that matches the provided query is returned.</p>

<pre><code>dao.select(:favourite_foods).elem_match(
  dao.where(:price).lte(5_00)
)
</code></pre>

<p>*
*
*
*
*
*</p>

<h3>
<a name="old-readme-below-this-line" class="anchor" href="#old-readme-below-this-line"><span class="octicon octicon-link"></span></a>Old README below this line</h3>

<h3>
<a name="configuration" class="anchor" href="#configuration"><span class="octicon octicon-link"></span></a>Configuration:</h3>

<pre><code># config/mongo.yml
development:
  animals:
    database: animals_development
    host: localhost
    pool_size: 5
    timeout: 5
    replicate_set_name: animals_development
    servers:
      - { host: localhost, port: 27017 }
</code></pre>

<h3>
<a name="initialisation" class="anchor" href="#initialisation"><span class="octicon octicon-link"></span></a>Initialisation:</h3>

<pre><code># config/initializers/daodalus.rb
Daodalus::Configuration.load('config/mongo.yml', Rails.env)
</code></pre>

<h5>
<a name="examples" class="anchor" href="#examples"><span class="octicon octicon-link"></span></a>Examples:</h5>

<pre><code>#!ruby
class CatDAO
  extend Daodalus::DAO # or `include` if you want an instance of a DAO
  target :animals, :cats # or overide `connection` to supply your own

  def self.example_find
    select(:name).where(:paws).less_than(4).find
  end

  def self.example_find_one
    where(:collar_id).eq("aochc986").find_one
  end

  def self.example_update
    set(:stray, true).where(:address).does_not_exist.update
  end

  def self.example_find_and_modify
    dec(:lives).
      push(:names, "Kitty").
      where(:stray).eq(true).
      and(:cuteness).gt(8).
      find_and_modify(new: true)
  end

  def self.example_remove
    where(:lives).eq(0).remove
  end

  def self.example_aggregation
    match(:lives).gt(3).
      and(:address).exists.
      unwind(:favourite_foods).
      group(:favourite_foods).
      min(min_paws: 'paws').
      sort(:_id).
      limit(10).
      project(:_id).as(:food).and(:min_paws).
      aggregate
  end
end
</code></pre>

<h2>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h2>

<p>Daodalus is Copyright © 2012-2013 On The Beach Ltd.
It is free software, and may be redistributed under the terms specified in the LICENSE file.</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>